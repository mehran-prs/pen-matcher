<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pen-Only Matcher</title>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; font-family: -apple-system, sans-serif;
            background: #fff; touch-action: none;
        }

        /* Minimalist Toolbar */
        .toolbar {
            position: fixed; top: 0; left: 0; width: 100%; height: 50px;
            background: rgba(255, 255, 255, 0.9); border-bottom: 1px solid #eee;
            display: flex; align-items: center; justify-content: center; gap: 20px;
            z-index: 1000;
        }

        #drawCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }

        /* Floating Reference */
        #floatingRef {
            position: absolute; top: 65px; right: 15px;
            width: 130px; background: white; border: 1.5px solid #000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1); border-radius: 4px; z-index: 2000;
        }
        #refHeader {
            height: 18px; background: #000; color: #fff; font-size: 9px;
            display: flex; align-items: center; justify-content: center;
            cursor: move; text-transform: uppercase;
        }
        #refCanvas { display: block; background: #fff; width: 100%; }

        /* UI Styling */
        .input-wrap { display: flex; align-items: center; gap: 8px; border-right: 1px solid #eee; padding-right: 15px; }
        input[type="number"] { width: 35px; border: 1px solid #ddd; border-radius: 4px; padding: 4px; font-size: 14px; }
        button {
            padding: 8px 20px; font-size: 13px; font-weight: 600; border-radius: 20px;
            border: none; cursor: pointer; transition: all 0.2s;
        }
        .btn-new { background: #f0f0f0; color: #333; }
        .btn-match { background: #007bff; color: white; }
        #scoreDisplay { font-weight: bold; color: #007bff; font-size: 18px; min-width: 50px; }

        /* Pen-only indicator */
        .mode-hint { position: fixed; bottom: 10px; right: 10px; font-size: 10px; color: #ccc; z-index: 50; }
    </style>
</head>
<body>

<div class="toolbar">
    <div class="input-wrap">
        <input type="number" id="lineCount" value="3" min="1" max="10">
        <button class="btn-new" onclick="startNewGame()">NEW</button>
    </div>
    <button class="btn-match" onclick="checkMatch()">MATCH</button>
    <div id="scoreDisplay">--%</div>
</div>

<canvas id="drawCanvas"></canvas>

<div id="floatingRef">
    <div id="refHeader">Move Window</div>
    <canvas id="refCanvas"></canvas>
</div>

<div class="mode-hint">Pen Input Only</div>

<script>
    const drawCanvas = document.getElementById('drawCanvas');
    const refCanvas = document.getElementById('refCanvas');
    const drawCtx = drawCanvas.getContext('2d');
    const refCtx = refCanvas.getContext('2d');
    const floatingRef = document.getElementById('floatingRef');

    let targetLines = [];
    let userLines = [];
    let isDrawing = false;
    let startPos = { x: 0, y: 0 };

    function syncLayout() {
        drawCanvas.width = window.innerWidth;
        drawCanvas.height = window.innerHeight;
        const screenRatio = window.innerHeight / window.innerWidth;
        const refWidth = 130;
        refCanvas.width = refWidth;
        refCanvas.height = refWidth * screenRatio;
    }

    window.addEventListener('resize', () => {
        syncLayout();
        renderUserLines();
    });

    // REJECTION LOGIC: Check if the pointer is a pen
    function isPen(e) {
        // pointerType can be 'mouse', 'pen', or 'touch'
        return e.pointerType === 'pen';
    }

    function getPos(e) {
        const rect = drawCanvas.getBoundingClientRect();
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }

    // --- Dragging Window (Allows touch/mouse so you can move it) ---
    let isDraggingRef = false;
    let dragOffset = { x: 0, y: 0 };

    floatingRef.onpointerdown = (e) => {
        isDraggingRef = true;
        dragOffset.x = e.clientX - floatingRef.offsetLeft;
        dragOffset.y = e.clientY - floatingRef.offsetTop;
        floatingRef.setPointerCapture(e.pointerId);
        e.stopPropagation();
    };
    floatingRef.onpointermove = (e) => {
        if (!isDraggingRef) return;
        floatingRef.style.left = (e.clientX - dragOffset.x) + 'px';
        floatingRef.style.top = (e.clientY - dragOffset.y) + 'px';
        floatingRef.style.right = 'auto';
    };
    floatingRef.onpointerup = () => isDraggingRef = false;

    // --- Drawing Logic (STRICT PEN ONLY) ---
    drawCanvas.onpointerdown = (e) => {
        if (!isPen(e) || isDraggingRef) return;
        isDrawing = true;
        startPos = getPos(e);
    };

    drawCanvas.onpointermove = (e) => {
        if (!isDrawing || !isPen(e)) return;
        renderUserLines();
        drawSingleLine(drawCtx, {x1: startPos.x, y1: startPos.y, x2: getPos(e).x, y2: getPos(e).y}, '#007bff', 2.5);
    };

    drawCanvas.onpointerup = (e) => {
        if (!isDrawing || !isPen(e)) return;
        const endPos = getPos(e);
        userLines.push({ x1: startPos.x, y1: startPos.y, x2: endPos.x, y2: endPos.y });
        isDrawing = false;
        renderUserLines();
    };

    function drawSingleLine(ctx, line, color, width, dash = []) {
        ctx.beginPath();
        ctx.setLineDash(dash);
        ctx.moveTo(line.x1, line.y1);
        ctx.lineTo(line.x2, line.y2);
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.lineCap = 'round';
        ctx.stroke();
        ctx.setLineDash([]);
    }

    function renderUserLines() {
        drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        userLines.forEach(l => drawSingleLine(drawCtx, l, '#007bff', 2.5));
    }

    // --- Game Logic ---
    function startNewGame() {
        userLines = [];
        targetLines = [];
        document.getElementById('scoreDisplay').innerText = '--%';
        drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        refCtx.clearRect(0, 0, refCanvas.width, refCanvas.height);

        syncLayout();

        const n = document.getElementById('lineCount').value;
        for (let i = 0; i < n; i++) {
            const line = {
                x1: Math.random() * (refCanvas.width - 20) + 10,
                y1: Math.random() * (refCanvas.height - 20) + 10,
                x2: Math.random() * (refCanvas.width - 20) + 10,
                y2: Math.random() * (refCanvas.height - 20) + 10
            };
            targetLines.push(line);
            drawSingleLine(refCtx, line, '#333', 1.5);
        }
    }

    function checkMatch() {
        if (userLines.length === 0) return;
        const ratio = drawCanvas.width / refCanvas.width;
        let totalScore = 0;

        targetLines.forEach(t => {
            const scaled = { x1: t.x1 * ratio, y1: t.y1 * ratio, x2: t.x2 * ratio, y2: t.y2 * ratio };
            drawSingleLine(drawCtx, scaled, 'rgba(255, 0, 0, 0.3)', 5, [10, 8]);

            let bestMatch = 0;
            userLines.forEach(u => {
                const d1 = Math.hypot(scaled.x1 - u.x1, scaled.y1 - u.y1) + Math.hypot(scaled.x2 - u.x2, scaled.y2 - u.y2);
                const d2 = Math.hypot(scaled.x1 - u.x2, scaled.y1 - u.y2) + Math.hypot(scaled.x2 - u.x1, scaled.y2 - u.y1);
                const score = Math.max(0, 100 - (Math.min(d1, d2) / 25));
                if (score > bestMatch) bestMatch = score;
            });
            totalScore += bestMatch;
        });

        document.getElementById('scoreDisplay').innerText = `${Math.round(totalScore / targetLines.length)}%`;
    }

    syncLayout();
    setTimeout(startNewGame, 100);

</script>
</body>
</html>
